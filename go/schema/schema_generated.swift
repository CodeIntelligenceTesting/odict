// automatically generated by the FlatBuffers compiler, do not modify

import FlatBuffers

public enum schema {

public enum POS: Int8, Enum { 
	public typealias T = Int8
	public static var byteSize: Int { return MemoryLayout<Int8>.size }
	public var value: Int8 { return self.rawValue }
	case verb = 0
	case noun = 1
	case adj = 2
	case pronoun = 3
	case adv = 4
	case prep = 5
	case conj = 6
	case intj = 7
	case prefix_ = 8
	case suffix = 9
	case particle = 10
	case article = 11
	case unknown = 12


	public static var max: POS { return .unknown }
	public static var min: POS { return .verb }
}

public struct Etymology: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsEtymology(bb: ByteBuffer) -> Etymology { return Etymology(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var description: String? { let o = _accessor.offset(6); return o == 0 ? nil : _accessor.string(at: o) }
	public var descriptionSegmentArray: [UInt8]? { return _accessor.getVector(at: 6) }
	public var usagesCount: Int32 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func usages(at index: Int32) -> schema.Usage? { let o = _accessor.offset(8); return o == 0 ? nil : schema.Usage(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public func usagesBy(key: schema.POS) -> schema.Usage? { let o = _accessor.offset(8); return o == 0 ? nil : schema.Usage.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
	public static func startEtymology(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 0)  }
	public static func add(description: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: description, at: 1)  }
	public static func addVectorOf(usages: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: usages, at: 2)  }
	public static func endEtymology(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createEtymology(_ fbb: FlatBufferBuilder,
		offsetOfId id: Offset<String> = Offset(),
		offsetOfDescription description: Offset<String> = Offset(),
		vectorOfUsages usages: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Etymology.startEtymology(fbb)
		Etymology.add(id: id, fbb)
		Etymology.add(description: description, fbb)
		Etymology.addVectorOf(usages: usages, fbb)
		return Etymology.endEtymology(fbb, start: __start)
	}
}

public struct Group: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsGroup(bb: ByteBuffer) -> Group { return Group(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var description: String? { let o = _accessor.offset(6); return o == 0 ? nil : _accessor.string(at: o) }
	public var descriptionSegmentArray: [UInt8]? { return _accessor.getVector(at: 6) }
	public var definitionsCount: Int32 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func definitions(at index: Int32) -> String? { let o = _accessor.offset(8); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public static func startGroup(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 0)  }
	public static func add(description: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: description, at: 1)  }
	public static func addVectorOf(definitions: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: definitions, at: 2)  }
	public static func endGroup(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createGroup(_ fbb: FlatBufferBuilder,
		offsetOfId id: Offset<String> = Offset(),
		offsetOfDescription description: Offset<String> = Offset(),
		vectorOfDefinitions definitions: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Group.startGroup(fbb)
		Group.add(id: id, fbb)
		Group.add(description: description, fbb)
		Group.addVectorOf(definitions: definitions, fbb)
		return Group.endGroup(fbb, start: __start)
	}
}

public struct Usage: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsUsage(bb: ByteBuffer) -> Usage { return Usage(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var pos: schema.POS { let o = _accessor.offset(4); return o == 0 ? .verb : schema.POS(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .verb }
	public var definitionsCount: Int32 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func definitions(at index: Int32) -> String? { let o = _accessor.offset(6); return o == 0 ? nil : _accessor.directString(at: _accessor.vector(at: o) + index * 4) }
	public var groupsCount: Int32 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func groups(at index: Int32) -> schema.Group? { let o = _accessor.offset(8); return o == 0 ? nil : schema.Group(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public static func startUsage(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(pos: schema.POS, _ fbb: FlatBufferBuilder) { fbb.add(element: pos.rawValue, def: 0, at: 0) }
	public static func addVectorOf(definitions: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: definitions, at: 1)  }
	public static func addVectorOf(groups: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: groups, at: 2)  }
	public static func endUsage(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createUsage(_ fbb: FlatBufferBuilder,
		pos: schema.POS = .verb,
		vectorOfDefinitions definitions: Offset<UOffset> = Offset(),
		vectorOfGroups groups: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Usage.startUsage(fbb)
		Usage.add(pos: pos, fbb)
		Usage.addVectorOf(definitions: definitions, fbb)
		Usage.addVectorOf(groups: groups, fbb)
		return Usage.endUsage(fbb, start: __start)
	}
	public static func sortVectorOfUsage(offsets:[Offset<UOffset>], _ fbb: FlatBufferBuilder) -> Offset<UOffset> {
		var off = offsets
		off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
		return fbb.createVector(ofOffsets: off)
	}
	fileprivate static func lookupByKey(vector: Int32, key: schema.POS, fbb: ByteBuffer) -> Usage? {
		var span = fbb.read(def: Int32.self, position: Int(vector - 4))
		var start: Int32 = 0
		while span != 0 {
			var middle = span / 2
			let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
			let comp = fbb.read(def: schema.POS.self, position: Int(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb)))
			if comp > 0 {
				span = middle
			} else if comp < 0 {
				middle += 1
				start += middle
				span -= middle
			} else {
				return Usage(fbb, o: tableOffset)
			}
		}
		return nil
	}
}

public struct Entry: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsEntry(bb: ByteBuffer) -> Entry { return Entry(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var term: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var termSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var etymologiesCount: Int32 { let o = _accessor.offset(6); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func etymologies(at index: Int32) -> schema.Etymology? { let o = _accessor.offset(6); return o == 0 ? nil : schema.Etymology(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public static func startEntry(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(term: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: term, at: 0)  }
	public static func addVectorOf(etymologies: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: etymologies, at: 1)  }
	public static func endEntry(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
	public static func createEntry(_ fbb: FlatBufferBuilder,
		offsetOfTerm term: Offset<String> = Offset(),
		vectorOfEtymologies etymologies: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Entry.startEntry(fbb)
		Entry.add(term: term, fbb)
		Entry.addVectorOf(etymologies: etymologies, fbb)
		return Entry.endEntry(fbb, start: __start)
	}
	public static func sortVectorOfEntry(offsets:[Offset<UOffset>], _ fbb: FlatBufferBuilder) -> Offset<UOffset> {
		var off = offsets
		off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: fbb.buffer), Table.offset(Int32($0.o), vOffset: 4, fbb: fbb.buffer), fbb: fbb.buffer) < 0 } 
		return fbb.createVector(ofOffsets: off)
	}
	fileprivate static func lookupByKey(vector: Int32, key: String, fbb: ByteBuffer) -> Entry? {
		let key = key.utf8.map { $0 }
		var span = fbb.read(def: Int32.self, position: Int(vector - 4))
		var start: Int32 = 0
		while span != 0 {
			var middle = span / 2
			let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
			let comp = Table.compare(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb), key, fbb: fbb)
			if comp > 0 {
				span = middle
			} else if comp < 0 {
				middle += 1
				start += middle
				span -= middle
			} else {
				return Entry(fbb, o: tableOffset)
			}
		}
		return nil
	}
}

public struct Dictionary: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsDictionary(bb: ByteBuffer) -> Dictionary { return Dictionary(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var id: String? { let o = _accessor.offset(4); return o == 0 ? nil : _accessor.string(at: o) }
	public var idSegmentArray: [UInt8]? { return _accessor.getVector(at: 4) }
	public var name: String? { let o = _accessor.offset(6); return o == 0 ? nil : _accessor.string(at: o) }
	public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: 6) }
	public var entriesCount: Int32 { let o = _accessor.offset(8); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func entries(at index: Int32) -> schema.Entry? { let o = _accessor.offset(8); return o == 0 ? nil : schema.Entry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public func entriesBy(key: String) -> schema.Entry? { let o = _accessor.offset(8); return o == 0 ? nil : schema.Entry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
	public static func startDictionary(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(id: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: id, at: 0)  }
	public static func add(name: Offset<String>, _ fbb: FlatBufferBuilder) { fbb.add(offset: name, at: 1)  }
	public static func addVectorOf(entries: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: entries, at: 2)  }
	public static func endDictionary(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createDictionary(_ fbb: FlatBufferBuilder,
		offsetOfId id: Offset<String> = Offset(),
		offsetOfName name: Offset<String> = Offset(),
		vectorOfEntries entries: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Dictionary.startDictionary(fbb)
		Dictionary.add(id: id, fbb)
		Dictionary.add(name: name, fbb)
		Dictionary.addVectorOf(entries: entries, fbb)
		return Dictionary.endDictionary(fbb, start: __start)
	}
}

}

// MARK: - schema


